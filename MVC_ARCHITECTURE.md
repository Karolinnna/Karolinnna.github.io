# MVC Архітектура та Альтернативні Підходи

## Як MVC реалізовано в нашому додатку

### Поточна реалізація (частково MVC)

Наш додаток використовує **гібридний підхід** з елементами MVC, але не є повноцінним MVC:

#### 1. **Controller (Контролер)** - `index.php`
- **Роль**: Обробка HTTP-запитів, роутинг, логіка авторизації
- **Функції**:
  - Парсинг URL та визначення маршрутів
  - Обробка POST-запитів (авторизація)
  - Управління сесіями
  - Редиректи

```php
// Приклад з index.php
if ($_SERVER["REQUEST_METHOD"] === "POST") {
    // Обробка авторизації (контролер)
    $login = trim($_POST["login"]);
    $password = trim($_POST["password"]);
    // ... логіка авторизації
}
```

#### 2. **View (Представлення)** - `Pages/`
- **Роль**: Відображення даних користувачу
- **Файли**: `home.php`, `login.php`, `404.php`, `500.php`
- **Функції**:
  - HTML-шаблони
  - Відображення даних з контролера
  - Екранування для захисту від XSS

```php
// Приклад з Pages/login.php
<h1><?= htmlspecialchars($title ?? 'Сторінка', ENT_QUOTES, 'UTF-8') ?></h1>
```

#### 3. **Model (Модель)** - `Models/` та `dbCreateTable.php`
- **Роль**: Робота з даними, бізнес-логіка
- **Файли**: 
  - `Models/User.php` - модель користувачів
  - `Models/Playlist.php` - модель плейлистів, треків, артистів
  - `Models/BaseModel.php` - базовий клас для моделей
  - `dbCreateTable.php` - клас Database (legacy)

```php
// Приклад з Models/User.php
class User extends BaseModel {
    public static function authenticate($login, $password) {
        // Логіка авторизації
    }
}
```

### Структура MVC в нашому додатку:

```
┌─────────────────────────────────────────┐
│         HTTP Request                    │
└──────────────┬──────────────────────────┘
               │
               ▼
┌─────────────────────────────────────────┐
│  Controller (index.php)                  │
│  - Роутинг                                │
│  - Обробка запитів                       │
│  - Виклик моделей                         │
└──────────────┬──────────────────────────┘
               │
       ┌───────┴────────┐
       │                │
       ▼                ▼
┌─────────────┐  ┌──────────────┐
│   Model     │  │    View      │
│ (Models/)  │  │  (Pages/)    │
│             │  │              │
│ - User      │  │ - home.php   │
│ - Playlist  │  │ - login.php  │
│ - Track     │  │ - 404.php    │
│ - Artist    │  │              │
└─────────────┘  └──────────────┘
       │
       ▼
┌─────────────┐
│  Database   │
│ (SQLite)    │
└─────────────┘
```

### Приклад потоку даних:

1. **Користувач відкриває `/login`**
   - Controller (`index.php`) обробляє маршрут
   - Controller визначає, що потрібно показати `Pages/login.php`
   - View (`login.php`) відображається користувачу

2. **Користувач відправляє форму авторизації**
   - Controller отримує POST-запит
   - Controller викликає Model (`User::authenticate()`)
   - Model перевіряє дані в БД
   - Controller отримує результат від Model
   - Controller перенаправляє на відповідну View

### Переваги поточної реалізації:
✅ Розділення відповідальності
✅ Легке додавання нових маршрутів
✅ Моделі інкапсулюють роботу з БД
✅ Views відповідають тільки за відображення

### Що можна покращити для повноцінного MVC:
- Створити окремі контролери для кожної сутності (UserController, PlaylistController)
- Винести логіку авторизації з `index.php` в окремий контролер
- Додати шаблонізатор для Views
- Створити Router клас для кращої організації маршрутів

---

## Інші архітектурні підходи (окрім MVC)

### 1. **MVP (Model-View-Presenter)**

**Відмінності від MVC:**
- **Presenter** замість Controller
- View не знає про Model
- Вся логіка в Presenter
- View пасивна, тільки відображає дані

**Структура:**
```
View ←→ Presenter ←→ Model
```

**Переваги:**
- Легше тестувати (View пасивна)
- Чітке розділення відповідальності
- View не залежить від Model

**Недоліки:**
- Більше коду
- Presenter може стати "божеським об'єктом"

---

### 2. **MVVM (Model-View-ViewModel)**

**Особливості:**
- **ViewModel** - зв'язує View та Model
- View біндиться до ViewModel
- Використовується в Angular, Vue.js, WPF

**Структура:**
```
View ←→ ViewModel ←→ Model
```

**Переваги:**
- Двостороннє зв'язування даних
- ViewModel легко тестувати
- Підходить для складних UI

**Недоліки:**
- Складніша для простих додатків
- Потрібні спеціальні фреймворки

---

### 3. **MVC-подібні варіанти:**

#### **HMVC (Hierarchical Model-View-Controller)**
- Вкладені модулі MVC
- Кожен модуль має свій MVC
- Використовується в CodeIgniter

#### **MMVC (Modular Model-View-Controller)**
- Модульна структура
- Кожен модуль - окремий MVC
- Легко додавати нові функції

---

### 4. **Архітектурні патерни без MVC:**

#### **Layered Architecture (Шарова архітектура)**
```
┌─────────────┐
│ Presentation│  (UI Layer)
├─────────────┤
│  Business   │  (Business Logic)
├─────────────┤
│   Data      │  (Data Access)
└─────────────┘
```

**Переваги:**
- Чітке розділення шарів
- Легко замінювати шари
- Підходить для великих проектів

---

#### **Clean Architecture / Hexagonal Architecture**
- **Domain** (ядро) - бізнес-логіка
- **Application** - use cases
- **Infrastructure** - БД, API
- **Presentation** - UI

**Переваги:**
- Незалежність від фреймворків
- Легко тестувати
- Масштабованість

---

#### **Repository Pattern**
- Абстракція доступу до даних
- Model не знає про БД
- Repository відповідає за CRUD

```php
class UserRepository {
    public function findById($id) { }
    public function save($user) { }
    public function delete($id) { }
}
```

---

#### **Service Layer Pattern**
- Бізнес-логіка в окремих сервісах
- Контролер викликає сервіси
- Сервіси використовують репозиторії

```php
class UserService {
    public function register($login, $password) {
        // Валідація, хешування, збереження
    }
}
```

---

### 5. **Microservices Architecture**

**Особливості:**
- Додаток розбитий на незалежні сервіси
- Кожен сервіс має свою БД
- Комунікація через API

**Переваги:**
- Масштабованість
- Незалежне розгортання
- Технологічна різноманітність

**Недоліки:**
- Складність управління
- Потрібна інфраструктура
- Складніше тестування

---

### 6. **Event-Driven Architecture**

**Особливості:**
- Компоненти спілкуються через події
- Слабке зв'язування
- Асинхронна обробка

**Приклад:**
```php
Event::fire('user.registered', $user);
Event::listen('user.registered', function($user) {
    // Відправити email
});
```

---

## Порівняння архітектур

| Архітектура | Складність | Масштабованість | Тестованість | Підхід |
|-------------|------------|-----------------|--------------|--------|
| **MVC** | Середня | Добра | Добра | Web додатки |
| **MVP** | Середня | Добра | Відмінна | Desktop/Web |
| **MVVM** | Висока | Відмінна | Відмінна | SPA, Desktop |
| **Layered** | Висока | Відмінна | Відмінна | Enterprise |
| **Clean** | Дуже висока | Відмінна | Відмінна | Великі проекти |
| **Microservices** | Дуже висока | Відмінна | Складність | Розподілені системи |

---

## Висновок

**MVC** - найпопулярніша архітектура для веб-додатків, оскільки:
- Проста для розуміння
- Добре підходить для більшості проектів
- Має велику підтримку в фреймворках
- Легко масштабується

**Наш додаток** використовує спрощений MVC, який можна покращити, додавши:
- Окремі контролери
- Service Layer
- Repository Pattern
- Кращу організацію Views

Для Spotify-подібного додатку MVC - оптимальний вибір, оскільки:
- Чітке розділення логіки (плейлисти, треки, артисти)
- Легко додавати нові функції
- Моделі інкапсулюють складну бізнес-логіку

